
> **18 Lessons From 13 Years of Tricky Bugs**

-----
原文请参见[**`这里`**](https://henrikwarne.com/2016/06/16/18-lessons-from-13-years-of-tricky-bugs/?utm_source=wanqu.co&utm_campaign=Wanqu%20Daily&utm_medium=website)

-----
在[**`从你的bug中学习`**](https://henrikwarne.com/2016/04/28/learning-from-your-bugs/)一文中, 我描述了如何记录所遇到过的有趣的bug的. 近期我回顾了194项记录(在过去的13年里), 来理解从中学到了那些经验. 这里是最重要的经验. 分成编码,测试和debug这三类.

-----
![pic1](https://henrikwarne1.files.wordpress.com/2016/06/dsc_1104.jpg?w=300&h=225)

> **编码**

以下是所有造成困难的bug的问题点:

1. 事件顺序.

    当处理事件时, 询问以下问题会非常有帮助: 

 - 事件会以不同的顺序发生吗?
 - 如果未能接收该事件会发生什么?
 - 如果该事件在一次处理中发生两次会怎样?

    即使通常时候以上情况不会发生, 但是系统中其他模块的bug(尤其是交互系统)可能会导致它们出现.

2. 太早发生.

    这是问题1中"事件顺序"的一个特例, 但它会造成一些麻烦的bugs, 所以被单独列出来. 

    例子1, 如果在相关配置和处理流程启动完成前, 信号消息过早被接收到, 很可能会发生奇怪的行为. 

    例子2, 当一个连接在被放进idle(空闲)列表前就被设置为down(关闭)状态.

    当debug例子2时, 我们总是预期只有当它在idle列表中才会被设置到down状态(那为什么它没有被从列表中移出呢?), 没有考虑到事情可能提前发生是我们猜想的一种错误情况.

3. 静默错误.

    某些非常难以被追查的bug, 来自代码中静默的发生错误, 并且继续执行下去而不是抛出错误警告.

    例子1: 进行系统调用(bind)后返回了错误, 但是并没有检查.

    例子2: 解析处理的代码在碰到一个错误的元素时仅仅是返回了, 而没有产生错误警告. 调用者会在此错误的基础上继续执行, 这将造成后续的debug更加困难. 

    正确的做法是在失败情况发生时立即返回错误信息.

4. If

    使用if判断多种情况, if(a 或 b), 特别是在联合判断, if(x) else if(y), 给我造成了很多bug. 尽管if判断是很简单的概念, 它们在处理多种条件时还是很容易出错. 有条件的情况下, 尽量重写代码中的if判断, 使用简单的方式来避免复杂条件出现.

5. Else

    很多bug是由于没有正确的处理如何在if判断一个条件失败时该如何操作的. 在大部分情况下, 每个if判断都应该有它的else部分. 而且, 如果你在if判断的一个分支中设置了某个变量, 那么你最好在另外的情况下也设置它. 

    例子1, 标识位设置时, 可能很容易出现仅仅在满足条件的情况下设置标识位, 而忘记了增加不满足条件下应该清除标识位的部分. 如果该标识位没有被清除, 在后续的执行中很有可能会引入bug.

6. 更改预期

    很多在第一线实际运用中难以避免避免的bug是由于它改变了预期而引起的. 

    例子1, 开始情况下, 每天只有一个客户事件. 后续的许多代码依据这个预期进行了编写. 之后的时间里, 该设计被改变以支持每天多个用户事件. 在这种情况下, 很难按照新设计的思路去修改原有所有的代码实例. 按照改动部分去查找所有的显式依赖是很容易的, 但是困难的部分在于去查看所有基于旧设计的隐式依赖. 

    例子2, 基于例子1, 某段代码负责每天去获取所有的用户事件, 那么它可能会包含获取事件的结果大小不会超过用户数目这样的假设. 对于这种问题我没有好的避免方案, 欢迎提供建议.

7. 记录

    纪录对于程序运行的可视性揭露是很关键的, 尤其是实现逻辑很复杂的情况下. 要确保已经加入了足够(但不要过多)的记录信息, 此时你能从中分析出为什么程序会这样执行. 当模块正常工作时, 记录不会有影响, 但当程序出问题时(这是一定的!), 你会很高兴已经增加了合适的记录手段.

-----
![pic-2](https://henrikwarne1.files.wordpress.com/2016/06/dsc_1071.jpg?w=300&h=225)


> **测试**

作为开发者, 在功能被测试前不能算作已经完成. 最低限度的情况下, 每行新加入或是修改的代码至少应该被执行一次. 此外, 单元测试或者功能测试都是应该的, 但这还不够. 新的功能应该在类似于使用环境下被运行和测试. 只有这些完成才能说明当前功能是完成的. 

以下是测试给我的深刻教训:

8. Zero(零) 和 Null(空)

    任何情况下都应该测试zero和null(它们是被允许的). 对于字符串来讲, 它意味着这个字符串的长度是0, 同时内容为空. 

    例子1: 在任何数据(零字节)的数据被发送至TCP链接之前测试它的连通性. 

    没有对这些联合的条件进行充分测试, 是测试时经常出现的遗漏, 这也是这些bug产生的第一号的原因.

9. 增加和移除.

    通常情况下, 加入的新功能会在系统中引入新的配置. 

    例子1, 在系统中增加新的电话号码转换方式后. 很容易就能想到在增加新配置后来进行测试, 但是同样也很容易忘记在该新配置被移除后也要进行同样的测试.

10. 错误处理.

    错误处理的代码通常难以被测试. 最好能够使用自动测试机制来对错误处理代码进行检查, 但有时候这是不可行的.

    例子1, 有时候我会使用一些花招, 比如零时修改代码来使错误处理的代码执行. 最简单的方法是对if条件判断进行反转, 比如将**`if error_count >0`** 改成 **`if error_count<0`**. 

    例子2, 通过错误拼写数据库的字段名来促使预期的错误处理代码执行.

11. 随机输入.

    通常使用随机的输入来检查, 可以造成一些bug出现. 

    例子1, H.323协议的ASN.1解码是基于二进制数据的. 通过向它发送一些随机产生的字节, 我们在解码器中发现了许多bug. 

    例子2, 使用测试脚本来调用接口, 在调用开始后, 延时响应回复, 并直接关闭调用部分, 这样会造成随机的混乱状态. 类似的测试脚本能够暴露许多的bugs, 尤其是当存在有事件发生和关闭同时处理的接口的时候.

12. 检查不可能发生的情况.

    大多数的检查只包含有对预期操作产生的情况. 但同时加入对相反情况的检查也是很容易加入的 - 去检查一个不应当发生而且实际上也不会发生的操作. 也是很有必要的.

13. 自造工具.

    通常情况下我会创建自己的小工具来使测试变得简单.

    例子1, 当我为了VOIP功能而工作在SIP协议上时, 我编写了个小脚本, 用以回复我正好需要的头信息和值. 这个工具使得对于边界情况的测试变的简单.

    例子2, 使用命令行工具来进行API调用, 一开始它比较小, 随后按照需要的功能逐渐增加, 最后我完成了一个非常有用的工具. 

    编写自己的测试工具的好处是我能够正好得到我所需要的东西.

在测试过程中发现所有的bug是绝对不可能的. 

  在某个bug实例中, 我对处理由两部分组成的数据的代码进行了修改, 这两部分一个是进程地址的前缀(每次都一样), 另一个是从000到999的动态分配的数. 问题发生在对表中的相关数据进行查找之前, 随机分配的数的第一位被错误的移除掉了. 所以假设需要查找的是637，实际传入的是37, 而这个数不在表里面. 这导致当前的机制在100之前是工作的, 所以前100次调用是正确的, 而后面所有的900次都会出错. 所以除非我能够在程序重启前(没法做到)执行超过100次的测试, 否则无法发现这个问题.

-----
![pic-3](https://henrikwarne1.files.wordpress.com/2016/06/dsc_2462.jpg?w=300&h=225)

> **修正错误**

14. 讨论.

  在我过去的日子里, 对我帮助最大的debug技术是在合作者间进行讨论. 

  例子1, 通常向我的合作者简单的描述这个问题就能让我明白这个问题所悟在哪了. 此外, 即使他们对产生问题的代码并不熟悉, 他们也能从各种角度上提出那里可能出错的好的想法. .

  同合作者进行讨论可能是我在解决大部分困难的bug时最有效率的方法.

15. 近距离观察.

    通常在debug一个问题需要很长的时间时, 基本都是由于我做了错误的假设. 

    例子1, 我以为这个错误发生在某个特定的方法中, 而实际情况中它甚至都没有对这个方法产生调用.

    例子2, 抛出异常的处理函数不是我预期的哪个.

    例子3, 我以为当前运行的是最新的版本, 而实际上运行是稍微老些的版本.

    因此, 在假定之前先对细节进行验证. **你总是容易看到你所希望看到的, 而不是实际发生的事情**(**`Tips: 好有哲理的一句话`**).

16. 最近的改动.

    当以前工作的东西不工作了的时候, 通常它是由最后的修改所引起的. 

    例子1, 最后一次修改是增加纪录, 但是log中的错误导致了更大的问题. 为了使得这样的回退能够被更容易的查找出来, 将不同的修改放到不同的提交中会很有帮助, 并且在commit中对修改进行清楚的描述.

17. 相信用户.

    某些时候当用户报告了一个问题时, 我的第一反应是: “这不可能, 他们一定是搞错了什么“. 但是我现在学到了我不能以这种方式来进行反应. 更多次的情况是, 他们所报告的问题真实的发生了. 

    所以这些时候, 我将他们的报告放到面前, 当然我任然会再次去确认所有的配置都被正确设置等等. 但是我还是看到很多次的奇怪的事情发生, 是因为不常见的配置或者是没有想到的操作所引起的, 所以现在我的默认假定是他们是对的, 程序是错误的.

18. 对修改进行测试.

    当修正错误的代码完成后, 它需要被测试. 首先不使用该修改来运行程序, 并重现错误. 然后将修改加入, 重复测试项. 现在错误行为应当不会出现了. 进行这些步骤能够保证它确实是一个bug, 并且对应的修改确实修正了它. 这很简单, 同时也很必要.

-----
![pic-4](https://henrikwarne1.files.wordpress.com/2016/06/dsc_2624.jpg?w=300&h=225)

> **其它发现**

在过去的处理我遇到的最棘手的bug的13年间, 很多事情都发生了改变. 我曾经工作在小的嵌入式系统上, 也工作在大的交换系统上, 同时也在基于web的系统上工作过.

我使用过C++, Ruby, Java和Python. 在我使用C++过程中的很多类性的bug现在都已经消失了, 它们包括栈溢出, 内存损坏, 字符串问题和某些形式的内存泄漏.

其它的问题, 类似于循环错误和边界问题, 我发现的越来越少, 因为我的单元测试越来越有逻辑性. 但这不代表没有bugs - 仍然有bug. 

这篇文章中提到的帮助我减少损失的内容分为编码,测试和修正. 如果你在debug过程中有更多的方法和技术, 请在评论中和我讨论.

-----